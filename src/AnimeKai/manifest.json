{
  "id": "animekai",
  "name": "AnimeKai",
  "description": "AnimeKai is an online streaming provider for subbed/dubbes animes in English",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/AnimeKai/manifest.json",
  "version": "1.1.0",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\"/>\n\nclass Provider {\n  api = \"https://animekai.to\";\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Server 1\", \"Server 2\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    let normalizedQuery = this.normalizeQuery(query[\"query\"]);\n    console.log(\"Normalized Query: \" + normalizedQuery);\n\n    const url = `${this.api}/browser?keyword=${encodeURIComponent(\n      normalizedQuery\n    )}`;\n\n    try {\n      const data = await this._makeRequest(url);\n      const $ = LoadDoc(data);\n      const animes: SearchResult[] = [];\n      $(\"div.aitem-wrapper>div.aitem\").each((_, elem) => {\n        const id = elem.find(\"a.poster\").attr(\"href\")?.slice(1) ?? \"\";\n        const title = elem.find(\"a.title\").attr(\"title\") ?? \"\";\n        const subOrDub: SubOrDub = this.isSubOrDubOrBoth(elem);\n        const url = `${this.api}/${id}`;\n        console.log(`Found: ${title} - ${url} - ${subOrDub}`);\n\n        const anime: SearchResult = {\n          id: `${id}?dub=${query['dub']}`,\n          url: url,\n          title: title,\n          subOrDub: subOrDub,\n        };\n\n        animes.push(anime);\n      });\n\n      return animes;\n    }\n    catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n\n    const url = `${this.api}/${id.split('?dub')[0]}`;\n    const rateBoxIdRegex = /<div class=\"rate-box\"[^>]*data-id=\"([^\"]+)\"/;\n    try {\n      let data: any = await this._makeRequest(url);\n      const idMatch = data.match(rateBoxIdRegex);\n      const aniId = idMatch ? idMatch[1] : null;\n\n      const token = await this._makeRequest(`https://ilovekai.simplepostrequest.workers.dev/?ilovefeet=${encodeURIComponent(aniId)}`);\n\n      const fetchUrlListApi = `${this.api}/ajax/episodes/list?ani_id=${aniId}&_=${token}`;\n      const responseTextListApi = await this._makeRequest(fetchUrlListApi);\n      data = await JSON.parse(responseTextListApi);\n\n      const $ = LoadDoc(data.result);\n\n      const episodeData = $('ul.range>li>a').map((_, elem) => ({\n        name: `Episode ${elem.attr('num')}`,\n        number: parseInt(elem.attr('num')!, 10),\n        data: elem.attr('token'),\n        title: elem.find('span').text().replace(/\\s/g, ' ')\n      }));\n\n      const batchResponse = await fetch(\"https://ilovekai.simplepostrequest.workers.dev/?ilovefeet\",\n        {\n          method: \"POST\",\n          body: JSON.stringify(episodeData.map((item) => ({ name: item.name, data: item.data }))),\n        }\n      );\n\n      //const episodes: EpisodeDetails[] = [];\n      const batchResults = await batchResponse.json();\n\n      const episodes: EpisodeDetails[] = batchResults.map((result: any, index: number) => ({\n        id: episodeData[index].data ?? \"\",\n        number: episodeData[index].number,\n        title: episodeData[index].title,\n        url: `${this.api}/ajax/links/list?token=${episodeData[index].data}&_=${result.data}?dub=${id.split('?dub=')[1]}`\n      }));\n\n      return episodes;\n    }\n    catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodeServer(\n    episode: EpisodeDetails,\n    _server: string\n  ): Promise<EpisodeServer> {\n    let server = \"Server 1\";\n    if (_server !== \"default\") server = _server;\n\n    const episodeUrl = episode.url.replace('\\u0026', '&').split('?dub')[0];\n    const dubRequested = episode.url.split('?dub=')[1];\n\n    console.log(\"Episode URL: \" + episodeUrl);\n\n    try {\n      const responseText = await this._makeRequest(episodeUrl);\n\n      const cleanedHtml = cleanJsonHtml(responseText);\n      const subRegex = /<div class=\"server-items lang-group\" data-id=\"sub\"[^>]*>([\\s\\S]*?)<\\/div>/;\n      const softsubRegex = /<div class=\"server-items lang-group\" data-id=\"softsub\"[^>]*>([\\s\\S]*?)<\\/div>/;\n      const dubRegex = /<div class=\"server-items lang-group\" data-id=\"dub\"[^>]*>([\\s\\S]*?)<\\/div>/;\n\n      const subMatch = subRegex.exec(cleanedHtml);\n      const softsubMatch = softsubRegex.exec(cleanedHtml);\n      const dubMatch = dubRegex.exec(cleanedHtml);\n\n      const sub = subMatch ? subMatch[1].trim() : \"\";\n      const softsub = softsubMatch ? softsubMatch[1].trim() : \"\";\n      const dub = dubMatch ? dubMatch[1].trim() : \"\";\n\n      let streamUrl: any = \"\";\n      let serverSpanRegex: any = \"\";\n\n      console.log(dub, sub);\n\n      // Find server 1 span and extract data-lid\n      if (server == \"Server 1\")\n        serverSpanRegex = /<span class=\"server\"[^>]*data-lid=\"([^\"]+)\"[^>]*>Server 1<\\/span>/;\n      else\n        serverSpanRegex = /<span class=\"server\"[^>]*data-lid=\"([^\"]+)\"[^>]*>Server 2<\\/span>/;\n\n      const serverMatch = dubRequested === 'true' ? serverSpanRegex.exec(dub) : serverSpanRegex.exec(sub);\n\n      console.log(\"SERVER MATCH\", serverMatch);\n\n      const serverIdDub = serverSpanRegex.exec(dub)?.[1];\n      const serverIdSoftsub = serverSpanRegex.exec(softsub)?.[1];\n      const serverIdSub = serverSpanRegex.exec(sub)?.[1];\n\n      //serverId = serverMatch[1];\n      const tokenRequestData = [\n        { name: \"Dub\", data: serverIdDub },\n        { name: \"Softsub\", data: serverIdSoftsub },\n        { name: \"Sub\", data: serverIdSub }\n      ].filter(item => item.data);\n\n      const tokenBatchResponse = await fetch(\n        \"https://ilovekai.simplepostrequest.workers.dev/?ilovefeet\",\n        {\n          method: \"POST\",\n          body: JSON.stringify(tokenRequestData)\n        }\n      );\n      const tokenResults = await tokenBatchResponse.json();\n      const streamUrls = tokenResults.map((result: any) => {\n        const serverIdMap: any = {\n          \"Dub\": serverIdDub,\n          \"Softsub\": serverIdSoftsub,\n          \"Sub\": serverIdSub\n        };\n        return {\n          type: result.name,\n          url: `https://animekai.to/ajax/links/view?id=${serverIdMap[result.name]}&_=${result.data}`\n        };\n      });\n\n      const decryptedUrls = await processStreams(streamUrls);\n\n      const headers = {\n        \"Referer\": \"https://animekai.to/\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\"\n      };\n\n      streamUrl = dubRequested === 'true' ? decryptedUrls.Dub : (decryptedUrls.Sub ?? decryptedUrls.Softsub);\n\n      if (streamUrl == \"\") {\n        throw new Error(\"Unable to find a valid source\")\n      }\n\n      const streams = await fetch(streamUrl.replace(\"/e/\", \"/media/\"), {\n        headers: headers\n      });\n\n      const responseJson = await streams.json();\n      const result = responseJson?.result;\n      const postData = {\n        \"text\": result,\n        \"Useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\"\n      }\n\n      const finalResponse = await fetch(\"https://ilovekai.simplepostrequest.workers.dev/ilovebush\", {\n        method: \"POST\",\n        body: JSON.stringify(postData)\n      });\n\n      const finalJson = await finalResponse.json();\n\n      console.log(finalJson);\n      const m3u8Link = finalJson?.result?.sources?.[0]?.file;\n      const playlistResponse = await fetch(m3u8Link);\n\n      //Regex to extract all the resolutions and url related to the resolutions available\n      const regex = /#EXT-X-STREAM-INF:BANDWIDTH=\\d+,RESOLUTION=(\\d+x\\d+)\\s*(.*)/g;\n      const videoSources: VideoSource[] = [];\n\n      let resolutionMatch;\n\n      while ((resolutionMatch = regex.exec(await playlistResponse.text())) !== null) {\n\n        let url = \"\";\n\n        if (resolutionMatch[2].includes(\"list\")) {\n          url = `${m3u8Link.split(',')[0]}/${resolutionMatch[2]}`;\n        }\n        else {\n          url = `${m3u8Link.split('/list')[0]}/${resolutionMatch[2]}`\n        }\n        \n        const episodeRealPlaylist = await fetch(url);\n        console.log(await episodeRealPlaylist.text());\n\n        videoSources.push({\n          quality: resolutionMatch[1].split('x')[1] + 'p', // 1920x1080 -> 1080p\n          subtitles: [], //Subs are already integrated in the video source\n          type: 'm3u8', //Standard type for AnimeKai\n          url: url\n        });\n      }\n\n      const episodeServer: EpisodeServer = {\n        server: server,\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0'\n        },\n        videoSources: [...videoSources]\n      };\n\n      return episodeServer\n\n    }\n    catch (e: any) {\n      throw new Error(e);\n    }\n  }\n\n  normalizeQuery(query: string): string {\n    let normalizedQuery = query\n      .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, \"$1\") //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n      .replace(/\\s+/g, \" \") //Replaces 1+ whitespaces with 1 whitespace\n      .replace(/(\\d+)\\s*Season/i, \"$1\") //Removes season and keeps the number before the Season word\n      .replace(/Season\\s*(\\d+)/i, \"$1\") //Removes season and keeps the number after the Season word\n      .trim();\n\n    return normalizedQuery;\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        \"DNT\": \"1\",\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0\",\n        Cookie: \"__ddg1_=;__ddg2_=;\",\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n    const body = await response.text();\n    return body;\n  }\n\n  isSubOrDubOrBoth(elem: DocSelection): SubOrDub {\n    const sub = elem.find(\"span.sub\").text();\n    const dub = elem.find(\"span.dub\").text();\n\n    if (sub != \"\" && dub != \"\") {\n      return \"both\";\n    }\n    if (sub != \"\") {\n      return \"sub\";\n    }\n\n    return \"dub\";\n  }\n}\n\n//Dinamically getting the KAICODEX script from the repository\nasync function loadKaiCodex() {\n  const response = await fetch('https://raw.githubusercontent.com/amarullz/kaicodex/refs/heads/main/generated/kai_codex.js');\n  const code = await response.text();\n\n  const sandbox: Record<string, any> = {};\n\n  const KAICODEX = new Function('sandbox', `\n    const exports = {};\n    const module = { exports };\n    let result;\n    (function() {\n      ${code}\n      result = KAICODEX;\n    })();\n    return result;\n  `)();\n\n  return KAICODEX;\n}\n\n\nfunction cleanHtmlSymbols(string: string) {\n  if (!string) return \"\";\n\n  return string\n    .replace(/&#8217;/g, \"'\")\n    .replace(/&#8211;/g, \"-\")\n    .replace(/&#[0-9]+;/g, \"\")\n    .replace(/\\r?\\n|\\r/g, \" \")  // Replace any type of newline with a space\n    .replace(/\\s+/g, \" \")       // Replace multiple spaces with a single space\n    .trim();                    // Remove leading/trailing whitespace\n}\n\nfunction cleanJsonHtml(jsonHtml: string) {\n  if (!jsonHtml) {\n    return \"\";\n  }\n  return jsonHtml\n    .replace(/\\\\\"/g, \"\\\"\")\n    .replace(/\\\\'/g, \"'\")\n    .replace(/\\\\\\\\/g, \"\\\\\")\n    .replace(/\\\\n/g, \"\\n\")\n    .replace(/\\\\t/g, \"\\t\")\n    .replace(/\\\\r/g, \"\\r\");\n}\n\nasync function processStreams(streamUrls: any) {\n  const streamResponses = await Promise.all(\n    streamUrls.map(async ({ type, url }: any) => {\n      try {\n        const res = await fetch(url);\n        const json = await res.json();\n        return {\n          type: type,\n          result: json.result\n        };\n      } catch (error) {\n        console.log(`Error fetching ${type} stream:`, error);\n        return {\n          type: type,\n          result: null\n        };\n      }\n    })\n  );\n\n  const decryptRequestData = streamResponses\n    .filter(item => item.result)\n    .map(item => ({\n      name: item.type,\n      data: item.result\n    }));\n\n  if (decryptRequestData.length === 0) {\n    return {};\n  }\n\n  const decryptBatchResponse = await fetch(\n    \"https://ilovekai.simplepostrequest.workers.dev/?ilovearmpits\",\n    {\n      method: \"POST\",\n      body: JSON.stringify(decryptRequestData)\n    }\n  );\n  const decryptResults = await decryptBatchResponse.json();\n\n  const finalResults: any = {};\n  decryptResults.forEach((result: any) => {\n    try {\n      const parsed = JSON.parse(result.data);\n      finalResults[result.name] = parsed.url;\n      console.log(`decrypted${result.name} URL:` + parsed.url);\n    } catch (error) {\n      console.log(`Error parsing ${result.name} result:`, error);\n      finalResults[result.name] = null;\n    }\n  });\n\n  return finalResults;\n};\n\n\n"
}