{
  "id": "animesaturn",
  "name": "AnimeSaturn",
  "description": "AnimeSaturn is an online streaming provider for subbed/dubbed animes in Italian",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/AnimeSaturn/manifest.json",
  "version": "1.0.1",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "it",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\" />\n\nclass Provider {\n\n    private apiUrl = \"https://www.animesaturn.cx\";\n    private threshold = 0.7;\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"Server 1\"],\n            supportsDub: true,\n        }\n    }\n\n    async search(query: SearchOptions): Promise<SearchResult[]> {\n\n        let normalizedQuery = normalizeQuery(query.query)\n\n        console.log(\"Normalized query:\", normalizedQuery);\n\n        let aniListData: AniListAnimeDetails = await getAniListAnimeDetails(query['query']);\n        const aniListTitlesAndSynonyms = [...aniListData.title, ...aniListData.synonyms];\n\n        let url = `${this.apiUrl}/animelist?search=${encodeURIComponent(normalizedQuery)}`;\n\n        let html = await _makeRequest(url);\n\n        if (html.includes(\"Non sono stati trovati risultati\")) {\n            normalizedQuery = addSeasonWordToQuery(normalizedQuery);\n\n            if (normalizedQuery === \"\") {\n                throw new Error(\"Error encountered while adding Season word to query: \" + query.query);\n            }\n            url = `${this.apiUrl}/animelist?search=${encodeURIComponent(normalizedQuery)}`;\n            html = await _makeRequest(url);\n        }\n\n        if (html.includes(\"Non sono stati trovati risultati\")) {\n            throw new Error(\"No results found for the query: \" + query.query);\n        }\n\n        const results: SearchResult[] = [];\n        const validTitles: { title: string; score: number }[] = [];\n        const totalPages:number|null = getPageNumbers(html);\n\n        if(totalPages == null){\n            throw new Error(\"No anime found\");\n        }\n\n        for (let i = 1; i <= totalPages; i++) {\n            if (i > 1) {\n\n                url = `${this.apiUrl}/animelist?page=${i}&search=${normalizedQuery}`;\n                try {\n                    html = await _makeRequest(url);\n                }\n                catch (error) {\n                    console.error(error);\n                }\n            }\n\n            let $ = LoadDoc(html);\n\n            $(\".item-archivio\").each((_, element) => {\n                const url = element.find(\"a\").attr(\"href\") || \"\";\n                const title = element.find(\".badge\").text().trim();\n                const id = url.split(this.apiUrl)[1]\n                const subOrDub: SubOrDub = GetSubOrDub(url);\n\n                let titleToCompareDub: string = \"\";\n\n                if (query.dub) {\n                    titleToCompareDub = title.replace(/\\s*\\(\\s*ita\\s*\\)\\s*/gi, \"\").trim();\n                }\n\n                try {\n                    let titleToSubmit:string = query.dub ? titleToCompareDub : title\n                    let bestScore: number | null = filterBySimilarity(titleToSubmit, aniListTitlesAndSynonyms, this.threshold);\n                    console.log(title, bestScore);\n                    if (bestScore != null) {\n                        validTitles.push({ title: title, score: bestScore });\n                    }\n                    console.log(validTitles);\n                }\n                catch (error) {\n                    console.error(\"Error: \" + error);\n                }\n\n                if (query.dub) {\n                    if (subOrDub === \"dub\") {\n                        results.push({\n                            id: id,\n                            title: title,\n                            url: url,\n                            subOrDub: subOrDub,\n                        });\n                    }\n                }\n                else {\n                    if (subOrDub === \"sub\") {\n                        results.push({\n                            id: id,\n                            title: title,\n                            url: url,\n                            subOrDub: subOrDub,\n                        });\n                    }\n                }\n            });\n        }\n\n        console.log(\"outside for\");\n        console.log(validTitles);\n\n        if (validTitles.length > 0) {\n            let bestMatch = validTitles.reduce((prev, current) => (prev.score > current.score) ? prev : current);\n            let animeToReturn = results.filter(anime => anime.subOrDub == (query['dub'] ? \"dub\" : \"sub\")).filter(anime => anime.title.toLowerCase() === bestMatch.title.toLowerCase())[0]; \n            \n            // {\n\n            //     if (query['dub']) {\n            //         const regex = /ita/i;\n            //         if (regex.test(anime.title) && (anime.title.toLowerCase() === bestMatch.title.toLowerCase())) {\n            //             return true;\n            //         }\n            //     }\n            //     else {\n            //         return anime.title.toLowerCase() === bestMatch.title.toLowerCase()\n            //     }\n            // })[0];\n\n            if (animeToReturn)\n                return [animeToReturn];\n        }\n        //If no valid title is found, return an error to avoid mismatches\n        // return [{\n        //     id:\"1\",\n        //     url: 'dnskfnsd',\n        //     title: 'sdjskldfs',\n        //     subOrDub:\"both\" \n        // }]\n        throw new Error(\"No results found\");\n    }\n\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n\n        const url = new URL(`${this.apiUrl}/${id}`);\n\n        const response = await fetch(url.toString());\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch episode details: \" + response.statusText);\n        }\n        const html = await response.text();\n        const $ = LoadDoc(html);\n\n        const episodes: EpisodeDetails[] = [];\n\n        $(\".episodes-button\").each((_, element) => {\n            const url = element.find(\"a.bottone-ep\").attr(\"href\") || \"\";\n            const title = element.find(\"a.bottone-ep\").text().trim();\n            const number: number = parseInt(url.split(\"-ep-\")[1]);\n            const id = url.split(this.apiUrl)[1]\n\n            episodes.push({\n                id: id,\n                number: number,\n                url: url,\n                title: title,\n            });\n        });\n\n        return episodes;\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n        let server = \"Server 1\"\n        if (_server !== \"default\") server = _server\n\n        const response = await fetch(episode.url);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch episode server: \" + response.statusText);\n        }\n        const html = await response.text();\n        const $ = LoadDoc(html);\n        const episodeServerUrl = $('a[href*=\"watch\"]').attr(\"href\") + \"&s=alt\" || \"\";\n        const episodeServerResponse = await fetch(episodeServerUrl);\n        if (!episodeServerResponse.ok) {\n            throw new Error(\"Failed to fetch episode server URL: \" + episodeServerResponse.statusText);\n        }\n        const episodeServerHtml = await episodeServerResponse.text();\n\n        const videoSources: VideoSource[] = [];\n        let eu: string = \"\";\n        let headers: any = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\",\n        };\n\n        const hlsUrlRegex = /<source[^>]+src=\"(https:\\/\\/[^\"]+\\.m3u8)\"/;\n        const hlsMatch = episodeServerHtml.match(hlsUrlRegex);\n\n        if (hlsMatch) {\n\n            eu = hlsMatch[1].trim();\n            console.log(\"HLS URL found:\", eu);\n\n            const hlsResponsed = await fetch(eu);\n            if (!hlsResponsed.ok) {\n                throw new Error(\"Failed to fetch HLS URL: \" + hlsResponsed.statusText);\n            }\n            const hlsText = await hlsResponsed.text();\n            const regex = /#EXT-X-STREAM-INF:BANDWIDTH=\\d+,RESOLUTION=(\\d+x\\d+)\\s*(.*)/g;\n\n\n            let resolutionMatch;\n            while ((resolutionMatch = regex.exec(hlsText)) !== null) {\n                let url = \"\";\n                if (resolutionMatch[2].includes(\"list\")) {\n                    url = `${eu.split('/playlist.m3u8')[0]}/${resolutionMatch[2].split('./')[1]}`;\n                }\n                else {\n                    url = `${hlsText.split('/list')[0]}/${resolutionMatch[2]}`\n                }\n                videoSources.push({\n                    quality: resolutionMatch[1].split('x')[1] + 'p', // 1920x1080 -> 1080p\n                    subtitles: [], //Subs are already integrated in the video source\n                    type: 'm3u8', //Standard type for AnimeKai\n                    url: url\n                });\n            }\n            let hostUrl = eu.split('https://')[1].split('/DDL')[0];\n            headers[\"Host\"] = hostUrl;\n            headers[\"Referer\"] = hostUrl;\n\n        }\n        else {\n            const mp4UrlRegex = /file:\\s*\"(https:\\/\\/[^\"]+\\.mp4)\"/;\n            const mp4Match = episodeServerHtml.match(mp4UrlRegex);\n\n            console.log(\"MP4 URL found:\", mp4Match);\n            eu = mp4Match ? mp4Match[1].trim() : \"\";\n\n\n            headers[\"Host\"] = eu.split('https://')[1].split('/DDL')[0];\n            headers[\"Referer\"] = eu.split('https://')[1].split('/DDL')[0];\n\n            videoSources.push({\n                quality: \"720p\",\n                subtitles: [], //Subs are already integrated in the video source\n                type: 'mp4', //Standard type for AnimeKai\n                url: eu\n            });\n        }\n\n        const episodeServer: EpisodeServer = {\n            server: server,\n            headers: headers,\n            videoSources\n\n        }\n        return episodeServer;\n    }\n}\n\n/**\n * Determines whether the anime is dubbed or subtitled based on the provided URL.\n * Assumes 'dub' if 'ita' is present and 'sub' is not explicitly mentioned.\n * \n * @param animeUrl \n * @returns \n */\n\nfunction GetSubOrDub(animeUrl: string): SubOrDub {\n\n    const url = animeUrl.toLowerCase();\n    if (url.includes(\"ita\") && !url.includes(\"sub\")) {\n        return \"dub\";\n    }\n\n    return \"sub\";\n\n}\n\nfunction normalizeQuery(query: string): string {\n\n    const extras = [\n        'EXTRA PART',\n        'OVA',\n        'SPECIAL',\n        'RECAP',\n        'FINAL SEASON',\n        'BONUS',\n        'SIDE STORY',\n        'PART\\\\s*\\\\d+',\n        'EPISODE\\\\s*\\\\d+'\n    ];\n\n    const pattern = new RegExp(`\\\\b(${extras.join('|')})\\\\b`, 'gi');\n\n    let normalizedQuery: string = query\n        .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1') //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n        .replace(/(\\d+)\\s*Season/i, '$1') //Removes season and keeps the number before the Season word\n        .replace(/Season\\s*(\\d+)/i, '$1') //Removes season and keeps the number after the Season word\n        .replace(pattern, '') //Removes extras\n        .replace(/-.*?-/g, '') // Removes -...-\n        .replace(/\\bThe(?=\\s+Movie\\b)/gi, '')\n        .replace(/~/g, ' ') //Removes ~\n        .replace(/\\s+/g, ' ') //Replaces 1+ whitespaces with 1\n        .trim();\n\n    const match = normalizedQuery.match(/[^a-zA-Z0-9 ]/);\n\n    if (match) {\n        const index = match.index!;\n        return normalizedQuery.slice(0, index).trim();\n    }\n\n    return normalizedQuery;\n}\n\n/**\n * Extracts the total number of pages from the provided HTML string.\n * Useful for paginated results (e.g., a search query that returns many results).\n * \n * @param html \n * @returns \n */\n\nfunction getPageNumbers(html: string): number | null {\n    if(html == null || html == \"\"){\n        return null;\n    }\n    const match = html.match(/totalPages\\s*:\\s*(\\d+)/i);\n\n    if (match && match[1]) {\n        const totalPages = parseInt(match[1], 10);\n        return totalPages\n    }\n\n    return 1;\n}\n\n\nfunction addSeasonWordToQuery(query: string): string {\n    if (/Season/i.test(query)) return query;\n\n    const match = query.match(/\\b(\\d+)(st|nd|rd|th)?\\b/);\n    if (!match || match.index === undefined) return query;\n    return \"\";\n}\n\n/**\n * Returns the HTML body of an HTTP response\n * \n * @param url -> The URL to fetch\n * @returns  A string with the response body, or a fallback message if any error occurs\n */\n\nasync function _makeRequest(url: string): Promise<string> {\n    try{\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'text/html; charset=utf-8',\n                'User-Agent':\n                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0',\n                Cookie: \"__ddg1_=;__ddg2_=;\"\n            },\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch: ${response.statusText}`);\n        }\n        const body = await response.text();\n        return body;\n    }\n    catch(error){\n        console.error(error);\n        return \"Non sono stati trovati risultati\";\n    }\n    \n}\n\n/**\n * \n * Returns the number of single-character edits required to change one word into another\n * \n * @param a -> String to compare\n * @param b -> String to be compared with\n * @returns \n */\n\nfunction levenshteinDistance(a: string, b: string): number {\n    const matrix: number[][] = [];\n\n    // Inizializza la prima colonna e riga della matrice\n    for (let i = 0; i <= a.length; i++) {\n        matrix[i] = [i];\n    }\n\n    for (let j = 0; j <= b.length; j++) {\n        matrix[0][j] = j;\n    }\n\n    // Calcola la distanza\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,    // Cancellazione\n                matrix[i][j - 1] + 1,    // Inserimento\n                matrix[i - 1][j - 1] + cost // Sostituzione\n            );\n        }\n    }\n\n    return matrix[a.length][b.length];\n}\n\n/**\n * \n * Returns the score based on the levenshtein distance algorithm\n * \n * @param a -> String to compare\n * @param b -> String to be compared with\n * @returns \n */\n\nfunction similarityScore(a: string, b: string): number {\n    const distance = levenshteinDistance(a, b);\n    const maxLen = Math.max(a.length, b.length);\n\n    console.log(\"DISTANCE: \" + distance);\n    console.log(\"MAXLEN: \"+ maxLen);\n    console.log(1 - distance/maxLen);\n\n    if (maxLen === 0) return 1; // Evita divisione per zero\n    return 1 - distance / maxLen;\n}\n\n/**\n * \n * Returns the highest score based on the levenshtein distance algorithm\n * \n * @param input -> String to compare\n * @param candidates -> String[] to compare the input with\n * @param threshold\n * @returns \n */\n\nfunction filterBySimilarity(input: string, candidates: string[], threshold: number): number | null {\n\n    if (!input || input.trim() === \"\") {\n        console.error(\"Invalid input string.\");\n        return null;\n    }\n\n    let validMatches = candidates\n        .map(candidate => ({\n            title: candidate,\n            score: similarityScore(normalizeStringBeforeLevenshtein(input), normalizeStringBeforeLevenshtein(candidate)),\n        }))\n        .filter(item => item.score >= threshold);\n\n    if (validMatches.length > 0) {\n        return validMatches.reduce((prev, current) => (prev.score > current.score) ? prev : current).score;\n    }\n\n    return null;\n\n}\n\n/**\n * Makes an HTTP request to the AniList API based on the specified parameter\n * \n * @param query \n * @param id \n * @returns \n */\n\nasync function getAniListAnimeDetails(query: string, id: number = 0): Promise<AniListAnimeDetails> {\n    const aniListAPI = 'https://graphql.anilist.co';\n    let variables = {};\n    let aniListQuery = '';\n\n    if (id == 0) {\n        variables = {\n            search: query,\n        };\n        aniListQuery = getAniListQueryString('search');\n    } else {\n        variables = {\n            mediaId: id,\n        };\n        aniListQuery = getAniListQueryString('id');\n    }\n\n    let options = {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            Accept: 'application/json',\n        },\n        body: JSON.stringify({\n            query: aniListQuery,\n            variables: variables,\n        }),\n    };\n    let responseGraph = await fetch(aniListAPI, options);\n\n    if (!responseGraph.ok) {\n        throw new Error(\n            `Failed to fetch search results: ${responseGraph.statusText}`\n        );\n    }\n\n    let data: GraphQLResponse = await responseGraph.json();\n    let animeYear = data.data.Media.startDate['year'];\n    let animeSynonyms = data.data.Media.synonyms;\n\n    const titles = [];\n    if (data.data.Media.title.english) {\n        titles.push(data.data.Media.title.english);\n    }\n    if (data.data.Media.title.romaji) {\n        titles.push(data.data.Media.title.romaji);\n    }\n\n    let animeDetails: AniListAnimeDetails = {\n        title: titles,\n        synonyms: animeSynonyms ?? [],\n        year: animeYear,\n    };\n\n    return animeDetails;\n}\n\n/**\n * Returns a string containing the query for AniList API\n * \n * @param type -> String representing the parameter to use for the fetch\n * @returns \n */\n\nfunction getAniListQueryString(type: string): string {\n    let query = `query`;\n\n    switch (type) {\n        case 'id':\n            query += `($mediaId: Int) {\n              Media(id: $mediaId) {`;\n            break;\n        case 'search':\n            query += `($search: String) {\n              Media(search: $search) {`;\n            break;\n    }\n    query += `id\n        title {\n          romaji\n          english\n          native\n        }\n        startDate {\n          day\n          month\n          year\n        }\n        meanScore\n        synonyms\n        updatedAt\n        coverImage {\n          large\n        }\n      }\n      }`;\n    return query;\n}\n\n/**\n * Replaces Season with empty string. \n * Keeps the number and not the suffix -> [2nd] = [2]\n * Replaces any number of sequential whitespace with just one\n * Converts the string to lower case\n *  \n * @param input \n * @returns \n */\n\nfunction normalizeStringBeforeLevenshtein(input: string): string {\n    const normalized = input.replace(/Season/gi, '').replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1').replace(/\\s+/g, ' ').trim().toLowerCase();\n    return normalized;\n}\n\n/**\n * Waits for ms milliseconds\n * \n * @param ms \n * @returns \n */\nfunction wait(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n\n\n/**\n * \n * INTERFACES\n * \n */\n\ninterface AniListAnimeDetails {\n    title: string[];\n    synonyms: string[];\n    year: number;\n}\n\ninterface GraphQLResponse {\n    data: {\n        Media: {\n            id: number;\n            title: {\n                romaji: string;\n                english: string;\n                native: string;\n            };\n            startDate: {\n                day: number;\n                month: number;\n                year: number;\n            };\n            meanScore: number;\n            synonyms: string[];\n            updatedAt: string;\n            coverImage: {\n                large: string;\n            };\n        };\n    };\n}\n"
}