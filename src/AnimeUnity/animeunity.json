{
  "id": "AnimeUnity",
  "name": "AnimeUnity",
  "description": "AnimeUnity is an online streaming provider for animes dubbed/subbed in Italian",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/AnimeUnity/animeunity.json",
  "version": "1.0.0",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "it",
  "payload": "/// <reference path=\"./onlinestream-provider.d.ts\" />\n/// <reference path=\"./core.d.ts\" />\n\nclass Provider {\n\n    private apiBaseUrl: string = \"https://www.animeunity.so\";\n    private cookies: string = \"\";\n    private cookiesExpirationDate: Date | null = null;\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"Server1\", \"Server2\"],\n            supportsDub: true,\n        }\n    }\n\n    async search(query: SearchOptions): Promise<SearchResult[]> {\n\n        let response: any;\n        let jsonData:any[] = [];\n        let data:any[] = [];\n\n        const validNames = [query['query'], query.media.englishTitle, query.media.romajiTitle, ...query.media.synonyms];\n\n        for (let validName of validNames) {\n            let normalizedQuery = this._normalizeQuery(validName ?? '');\n\n            console.log(\"NORMALIZED QUERY\", normalizedQuery);\n            response = await this._makeRequest('/archivio', \"GET\", { title: normalizedQuery }, null, \"text\");\n\n            const $ = LoadDoc(response);\n            jsonData = JSON.parse($('archivio').attr('records') || '[]');\n\n            if (jsonData.length === 0) continue;\n\n            const animeId = query.media.id;\n\n            data = jsonData.filter((x: any) => x?.anilist_id == animeId && x.dub == query.dub);\n\n            if(data.length !== 0) break;\n            \n            await this._sleep(200);\n        }\n\n        \n        let finalResults: SearchResult[] = data.map((item: any): SearchResult => (\n            {\n                id: `${item.id.toString()}-${item.slug}`,\n                title: item.title ?? item.title_eng ?? item.title_it,\n                url: `${this.apiBaseUrl}/anime/${item.id.toString()}-${item.slug}`,\n                subOrDub: item.dub == 1 ? 'dub' : 'sub'\n            }\n        ));\n\n        return finalResults;\n    }\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n\n        const animeId = id.split('-')[0];\n        let response = await this._makeRequest(`/info_api/${animeId}/0`, \"GET\", null, null, \"json\");\n        let episodesAmount = response[\"episodes_count\"];\n        const episodes = await this._getAnimeEpisodes(0, episodesAmount, animeId);\n\n        return episodes;\n    }\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n        let server = \"server1\"\n        if (_server !== \"default\") server = _server\n\n        let embedUrl = await this._makeRequest(episode.url, \"GET\", null, null, \"text\");\n\n        let response = await fetch(embedUrl);\n\n        if (!response.ok) {\n            console.error(\"An error occured during the embed scraping. Error: \" + response.statusText);\n            throw new Error(response.statusText);\n        }\n        const embedHtml = await response.text();\n\n        let playlistStreams: any = [];\n        let masterPlaylist: any;\n\n        if (embedHtml.includes('window.masterPlaylist')) {\n            let match = embedHtml.match(/window\\.masterPlaylist\\s*=\\s*({[\\s\\S]*?}\\s)/s);\n            if (match) {\n                let jsCode = `window = {}; window.masterPlaylist = ${match[1]}; return window.masterPlaylist;`;\n                masterPlaylist = new Function(jsCode)();\n                console.log(masterPlaylist);\n            }\n        }\n\n        if (embedHtml.includes('window.streams')) {\n            let match = embedHtml.match(/window\\.streams\\s*=\\s*(\\[[\\s\\S]*?\\]);/s);\n            if (match) {\n                let jsCode = `window = {}; window.streams = ${match[1]}; return window.streams;`;\n                playlistStreams = new Function(jsCode)();\n                console.log(playlistStreams);\n            }\n        }\n\n        // 2025-10-15 12:48:17 |DBG| log > {\"params\":{\"asn\":\"\",\"expires\":\"1765716497\",\"token\":\"8bad3efd1da2779741b47a3f0080d256\"},\"url\":\"https://vixcloud.co/playlist/304645?b=1\"}\n        // 2025-10-15 12:48:17 |DBG| log > [{\"active\":false,\"name\":\"Server1\",\"url\":\"https://vixcloud.co/playlist/304645?b=1\\u0026ub=1\"},{\"active\":1,\"name\":\"Server2\",\"url\":\"https://vixcloud.co/playlist/304645?b=1\\u0026ab=1\"}]\n\n        //GET Playlist urls\n        let playlistUrl = playlistStreams.filter((stream: any) => stream.name == server)[0][\"url\"].replace(\"\\u0026\", \"&\");\n        playlistUrl = `${playlistUrl}&token=${masterPlaylist.params.token}&expires=${masterPlaylist.params.expires}&h=1`;\n\n        response = await fetch(playlistUrl);\n        let playlistContent = response.text();\n\n        // #EXTM3U\n\n        // #EXT-X-STREAM-INF:BANDWIDTH=1200000,CODECS=\"avc1.640028,mp4a.40.2\",RESOLUTION=854x480\n\n        // https://vixcloud.co/playlist/304645?type=video&rendition=480p&token=0UAeINVLHokfgxA2XOmEbw&expires=1765717171&edge=au-u3-01\n\n        // #EXT-X-STREAM-INF:BANDWIDTH=2150000,CODECS=\"avc1.640028,mp4a.40.2\",RESOLUTION=1280x720\n\n        // https://vixcloud.co/playlist/304645?type=video&rendition=720p&token=eqC_pgU64QDVHP90n9g6IA&expires=1765717171&edge=au-u3-01\n\n        // #EXT-X-STREAM-INF:BANDWIDTH=4500000,CODECS=\"avc1.640028,mp4a.40.2\",RESOLUTION=1920x1080\n\n        // https://vixcloud.co/playlist/304645?type=video&rendition=1080p&token=FiJectPI0_goEM35lIwtuA&expires=1765717171&edge=au-u3-01\n\n        const lines: string[] = playlistContent.split('\\n').map((line: any) => line.trim()).filter(line => line !== '');\n        const streams: any[] = [];\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n\n            if (line.startsWith('#EXT-X-STREAM-INF')) {\n                const match = line.match(/RESOLUTION=(\\d+x\\d+)/);\n                const resolution = match ? match[1] : 'Unknown';\n\n                const url = lines[i + 1] || '';\n\n                streams.push({\n                    resolution: resolution.split('x')[1] + 'p',\n                    url: url\n                });\n            }\n        }\n\n        const videoSources: VideoSource[] = streams.map((stream: any): VideoSource => ({\n\n            quality: stream.resolution,\n            subtitles: [],\n            type: stream.url.includes('playlist') ? 'm3u8' : 'mp4',\n            url: stream.url\n\n        }));\n\n        const serverResult: EpisodeServer = {\n            server: server,\n            headers: {},\n            videoSources: videoSources\n        }\n\n        return serverResult;\n    }\n\n    async _updateCookies(): Promise<void> {\n\n        let now: Date = new Date();\n\n        if (this.cookiesExpirationDate == null || this.cookiesExpirationDate < now) {\n            try {\n                let response = await fetch(this.apiBaseUrl, { method: \"GET\", credentials: \"include\" });\n\n                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n\n                let cookies: string = JSON.parse(JSON.stringify(response.headers))[\"Set-Cookie\"];\n                let cookiesParts: string[] = cookies.split(\";\");\n                let expirationDateString: string = cookiesParts.find((p: string) => p.toLowerCase().startsWith(\"expires=\"))?.split(\"Expires=\")[1].split(\";\")[0].trim() || \"\";\n                this.cookiesExpirationDate = new Date(expirationDateString);\n                this.cookies = cookiesParts.find((p: string) => p.toLowerCase().startsWith(\"xsrf-token=\") ? p.trim() : \"\") || \"\";\n            }\n            catch (error: any) {\n                console.error(error);\n            }\n        }\n    }\n\n    async _makeRequest(endpoint: string, method: string = \"GET\", body: any = null, headers: any = null, returnType: \"json\" | \"text\" = \"text\"): Promise<string | any> {\n\n        try {\n            this._updateCookies();\n\n            if (!headers) headers = {}\n\n            if (this.cookies) headers[\"Cookie\"] = this.cookies\n            headers[\"User-Agent\"] = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n            let options: RequestInit = {\n                method: method,\n                headers: headers,\n                credentials: \"include\"\n            }\n\n            if (body) {\n                if (method === \"GET\") {\n                    endpoint += \"?\" + new URLSearchParams(body).toString()\n                } else {\n                    options.body = JSON.stringify(body)\n                    headers[\"Content-Type\"] = \"application/json\"\n                }\n            }\n            let response = await fetch(`${this.apiBaseUrl}/${endpoint}`, options)\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)\n\n            if (returnType === \"text\") return await response.text();\n\n            return await response.json()\n        }\n        catch (error: any) {\n            console.error(error);\n        }\n    }\n\n    async _getAnimeEpisodes(start: number, end: number, animeId: string | number, episodeLimitForIteration: number = 120): Promise<EpisodeDetails[]> {\n\n        const episodes: EpisodeDetails[] = [];\n        let current = start;\n        let endRange = Math.min(start + episodeLimitForIteration, end);\n\n        console.log(`START - Current: ${current} - endRange: ${endRange}`);\n\n        while (current < end) {\n            let response = await this._makeRequest(`/info_api/${animeId}/0?start_range=${current + 1}&end_range=${endRange}`, \"GET\", null, null, \"json\");\n\n            let returnedEpisoeds: EpisodeDetails[] = response.episodes.map((episode: any, index: number): EpisodeDetails => (\n                {\n                    id: episode.id.toString(),\n                    number: Number(episode.number) ?? index + 1,\n                    url: `embed-url/${episode.id.toString()}`\n                }\n            ));\n\n            episodes.push(...returnedEpisoeds);\n            current = endRange;\n            endRange = Math.min(current + episodeLimitForIteration, end);\n\n            console.log(`WHILE - Current: ${current} - endRange: ${endRange}`);\n        }\n        return episodes;\n    }\n\n    _normalizeQuery(query: string): string {\n\n        const extras = [\n            'EXTRA PART',\n            'OVA',\n            'SPECIAL',\n            'RECAP',\n            'FINAL SEASON',\n            'BONUS',\n            'SIDE STORY',\n            'PART\\\\s*\\\\d+',\n            'EPISODE\\\\s*\\\\d+'\n        ];\n\n        const pattern = new RegExp(`\\\\b(${extras.join('|')})\\\\b`, 'gi');\n\n        let normalizedQuery: string = query\n            .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1') //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n            .replace(/(\\d+)\\s*Season/i, '$1') //Removes season and keeps the number before the Season word\n            .replace(/Season\\s*(\\d+)/i, '$1') //Removes season and keeps the number after the Season word\n            .replace(pattern, '') //Removes extras\n            .replace(/-.*?-/g, '') // Removes -...-\n            .replace(/\\bThe(?=\\s+Movie\\b)/gi, '')\n            .replace(/~/g, ' ') //Removes ~\n            .replace(/\\s+/g, ' ') //Replaces 1+ whitespaces with 1\n            .replace('.', ' ')\n            .trim();\n\n        console.log('NORMA QUERY', normalizedQuery);\n        const match = normalizedQuery.match(/[^a-zA-Z0-9 ]/);\n\n        if (match) {\n            const index = match.index!;\n            console.log(\"MATCH\", index);\n            return normalizedQuery.slice(0, index).trim();\n        }\n\n        console.log('QUERY', query);\n        \n\n        return normalizedQuery;\n    }\n\n    _sleep(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n}"
}