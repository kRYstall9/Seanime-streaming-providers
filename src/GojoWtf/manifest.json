{
  "id": "gojowtf",
  "name": "GojoWtf",
  "description": "GojoWtf is an online streaming platform for English-subbed and dubbed anime. It supports multiple providers, including Pahe and Zaza â€” all of which offer both subbed and dubbed content",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/GojoWtf/manifest.json",
  "version": "1.1.1",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "en",
  "payload": "/// <reference path=\"./onlinestream-provider.d.ts\" />\n/// <reference path=\"./core.d.ts\" />\n\nclass Provider {\n\n    baseUrl: string = 'https://animetsu.to';\n    api: string = `https://backend.${this.baseUrl.split(\"://\")[1].split(\"/\")[0]}/api/anime`;\n    threshold: number = 0.7;\n    headers = {\n        'Referer': `${this.baseUrl}`,\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'\n    };\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"pahe\", \"zoro\", \"zaza\", \"bato\", \"megg\"],\n            supportsDub: true,\n        }\n    }\n\n    async search(query: SearchOptions): Promise<SearchResult[]> {\n        const normalizedQuery = normalizeQuery(query.query);\n        console.debug(normalizedQuery);\n\n        const language: string = query.dub ? \"dub\" : \"sub\";\n        let url = `${this.api}/search?query=${encodeURIComponent(normalizedQuery)}&page=1&year=${query.year != null ? query.year : 'any'}`;\n\n        try {\n            let response = await _makeRequest(url, this.headers);\n            let data = JSON.parse(response);\n\n            if (data?.total == 0) {\n                url = `${this.api}/search?query=${encodeURIComponent(query.query)}&page=1&year=${query.year != null ? query.year : 'any'}`;\n                response = await _makeRequest(url, this.headers);\n                data = JSON.parse(response);\n            }\n\n            const pages = data.lastPage;\n\n            const aniListTitlesAndSynonyms = [query.media.englishTitle ?? \"\", query.media.romajiTitle ?? \"\", ...query.media.synonyms];\n            const validTitles = new Map<string, LevenshteinResult>();\n            const results: SearchResult[] = [];\n            let shouldContinue: boolean = true;\n\n            for (let i = 1; i <= pages; i++) {\n                if (i > 1) {\n                    url = `${url.split(\"&page\")[0]}&page=${i}`;\n                    try {\n                        response = await _makeRequest(url, this.headers);\n                    }\n                    catch (error: any) {\n                        console.error(error);\n                    }\n                }\n\n                for (let anime of data.results) {\n                    let japaneseTitle = anime.title.romaji;\n                    let title = anime.title.english;\n                    let nativeTitle = anime.title.native;\n                    let id = anime.id;\n                    let url = `${this.baseUrl}/anime/${id}`;\n                    let subOrDub: SubOrDub = query.dub ? \"dub\" : \"sub\";\n                    const titles = [japaneseTitle, title, nativeTitle];\n\n                    try {\n                        for (let t of titles) {\n\n                            let bestScore: number | null = filterBySimilarity(t, aniListTitlesAndSynonyms, this.threshold);\n                            if (bestScore != null) {\n                                validTitles.set(title, { score: bestScore, subOrDub: subOrDub, title: title });\n                                if (bestScore == 1) {\n                                    shouldContinue = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    catch (error) {\n                        console.error(\"Error: \" + error);\n                    }\n\n                    results.push({\n                        id: `${id}/${subOrDub}`,\n                        title: title,\n                        url: url,\n                        subOrDub: subOrDub,\n                    });\n\n                    if (!shouldContinue)\n                        break;\n                }\n                if (!shouldContinue)\n                    break;\n            }\n\n            console.debug(validTitles);\n            if (validTitles.size > 0) {\n                let bestMatch = Array.from(validTitles.values()).reduce((prev, current) => (prev.score > current.score) ? prev : current);\n\n                console.log(\"Best Match \", bestMatch);\n                let animeToReturn = results.filter((anime: any) => anime.subOrDub == (query['dub'] ? \"dub\" : \"sub\")).filter((anime: any) => anime.title.toLowerCase() === bestMatch.title.toLowerCase())[0];\n\n                if (animeToReturn) {\n                    return [animeToReturn];\n                }\n            }\n\n            //Need this to force no results\n            throw new Error(\"No results found\");\n\n        }\n        catch (error: any) {\n            console.error(error);\n            throw new Error(error);\n        }\n    }\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n\n        const url = `${this.api}/eps/${id.split('/dub')[0].split('/sub')[0]}`;\n\n        console.log(url);\n\n        try {\n\n            const response = await _makeRequest(url, this.headers);\n            const data = JSON.parse(response);\n            const episodes: EpisodeDetails[] = [];\n\n            const providers: any = [];\n\n            for (let episode of data) {\n\n                episodes.push({\n                    id: `id=${id.split('/dub')[0].split('/sub')[0]}&num=${episode.number}&subType=${id.includes('/dub') ? 'dub' : 'sub'}`,\n                    number: episode.number,\n                    url: '',\n                    title: episode.title\n                })\n            }\n\n            return episodes;\n\n        }\n        catch (error: any) {\n            console.error(error);\n            throw new Error(error);\n        }\n    }\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n        let server = \"zaza\"\n        if (_server !== \"default\") server = _server\n\n        //TODO\n        //https://backend.animetsu.to/api/anime/servers?id=21&num=1 -> this.api/servers?${episode.id}\n        //Returns something like this\n        // [\n        //     {\n        //         \"id\": \"pahe\",\n        //         \"hasDub\": true,\n        //         \"default\": true\n        //     },\n        //     {\n        //         \"id\": \"zoro\",\n        //         \"hasDub\": true,\n        //         \"default\": false\n        //     },\n        //     {\n        //         \"id\": \"bato\",\n        //         \"hasDub\": true,\n        //         \"default\": false\n        //     },\n        //     {\n        //         \"id\": \"zaza\",\n        //         \"hasDub\": true,\n        //         \"default\": false\n        //     },\n        //     {\n        //         \"id\": \"meg\",\n        //         \"hasDub\": true,\n        //         \"default\": false\n        //     }\n        // ]\n\n        const serverProviders:any = await _makeRequest(`${this.api}/servers?${episode.id}`, this.headers);\n\n        if (serverProviders == null || serverProviders.length === 0) {\n            throw new Error(`No providers found for server ${_server}`);\n        }\n\n        const url = `${this.api}/tiddies?provider=${_server}&${episode.id}`;\n\n        try {\n            const response = await _makeRequest(url, this.headers);\n            const data = JSON.parse(response);\n            \n            if (data?.sources == null || data?.sources.length === 0) {\n                throw new Error(`No sources found for episode ${episode.number} on server ${_server}`);\n            }\n            \n            const videoSources: VideoSource[] = data.sources.map((source: any) => {\n                const splittedUrl: string[] = source.url.split(`https://${_server}.${this.baseUrl.split('//')[1]}/`);\n                const finalUrl = (splittedUrl.length >= 2 ? splittedUrl[1] : splittedUrl[0])?.replace(/[\\r\\n]+/g, '').trim();\n\n                console.log(\"URL with no \\\\n and \\\\r:\", finalUrl);\n\n                return {\n                    url: finalUrl,\n                    type: source.url.includes('m3u8') ? 'm3u8' : 'mp4',\n                    quality: source.quality,\n                    subtitles: []\n                }\n            });\n\n            return {\n                headers: this.headers,\n                server: server,\n                videoSources: videoSources\n            }\n        }\n        catch (error: any) {\n            console.error(error);\n            throw new Error(error);\n        }\n    }\n}\n\n\n/**\n * Returns the HTML body of an HTTP response\n * \n * @param url -> The URL to fetch\n * @returns  A string with the response body, or a fallback message if any error occurs\n */\n\nasync function _makeRequest(url: string, headers: any): Promise<string> {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: headers\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch: ${response.statusText}`);\n        }\n        const body = await response.text();\n        return body;\n    }\n    catch (error) {\n        console.error(error);\n        return \"\";\n    }\n\n}\n\n/**\n * \n * Returns the number of single-character edits required to change one word into another\n * \n * @param a -> String to compare\n * @param b -> String to be compared with\n * @returns \n */\n\nfunction levenshteinDistance(a: string, b: string): number {\n    const matrix: number[][] = [];\n\n    // Inizializza la prima colonna e riga della matrice\n    for (let i = 0; i <= a.length; i++) {\n        matrix[i] = [i];\n    }\n\n    for (let j = 0; j <= b.length; j++) {\n        matrix[0][j] = j;\n    }\n\n    // Calcola la distanza\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,    // Cancellazione\n                matrix[i][j - 1] + 1,    // Inserimento\n                matrix[i - 1][j - 1] + cost // Sostituzione\n            );\n        }\n    }\n\n    return matrix[a.length][b.length];\n}\n\n/**\n * \n * Returns the score based on the levenshtein distance algorithm\n * \n * @param a -> String to compare\n * @param b -> String to be compared with\n * @returns \n */\n\nfunction similarityScore(a: string, b: string): number {\n    const distance = levenshteinDistance(a, b);\n    const maxLen = Math.max(a.length, b.length);\n\n    // console.log(\"DISTANCE: \" + distance);\n    // console.log(\"MAXLEN: \"+ maxLen);\n    // console.log(1 - distance/maxLen);\n\n    if (maxLen === 0) return 1; // Evita divisione per zero\n    return 1 - distance / maxLen;\n}\n\n/**\n * \n * Returns the highest score based on the levenshtein distance algorithm\n * \n * @param input -> String to compare\n * @param candidates -> String[] to compare the input with\n * @param threshold\n * @returns \n */\n\nfunction filterBySimilarity(input: string, candidates: string[], threshold: number): number | null {\n\n    if (!input || input.trim() === \"\") {\n        console.error(\"Invalid input string.\");\n        return null;\n    }\n\n    let validMatches = candidates\n        .map(candidate => ({\n            title: candidate,\n            score: similarityScore(normalizeStringBeforeLevenshtein(input), normalizeStringBeforeLevenshtein(candidate)),\n        }))\n        .filter(item => item.score >= threshold);\n\n    if (validMatches.length > 0) {\n        return validMatches.reduce((prev, current) => (prev.score > current.score) ? prev : current).score;\n    }\n\n    return null;\n\n}\n\nfunction normalizeQuery(query: string): string {\n\n    const extras = [\n        'EXTRA PART',\n        'OVA',\n        'SPECIAL',\n        'RECAP',\n        'FINAL SEASON',\n        'BONUS',\n        'SIDE STORY',\n        'PART\\\\s*\\\\d+',\n        'EPISODE\\\\s*\\\\d+'\n    ];\n\n    const pattern = new RegExp(`\\\\b(${extras.join('|')})\\\\b`, 'gi');\n\n    let normalizedQuery: string = query\n        .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1') //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n        .replace(/(\\d+)\\s*Season/i, '$1') //Removes season and keeps the number before the Season word\n        .replace(/Season\\s*(\\d+)/i, '$1') //Removes season and keeps the number after the Season word\n        .replace(pattern, '') //Removes extras\n        .replace(/-.*?-/g, '') // Removes -...-\n        .replace(/\\bThe(?=\\s+Movie\\b)/gi, '')\n        .replace(/~/g, ' ') //Removes ~\n        .replace(/\\s+/g, ' ') //Replaces 1+ whitespaces with 1\n        .trim();\n\n    const match = normalizedQuery.match(/[^a-zA-Z0-9 ]/);\n\n    if (match) {\n        const index = match.index!;\n        return normalizedQuery.slice(0, index).trim();\n    }\n\n    return normalizedQuery;\n}\n\n/**\n * Replaces Season with empty string. \n * Keeps the number and not the suffix -> [2nd] = [2]\n * Replaces any number of sequential whitespace with just one\n * Converts the string to lower case\n *  \n * @param input \n * @returns \n */\n\nfunction normalizeStringBeforeLevenshtein(input: string): string {\n    const normalized = input.replace(/Season/gi, '').replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1').replace(/\\s*\\([^)]*\\)\\s*/gi, '').replace(/\\s+/g, ' ').trim().toLowerCase();\n    return normalized;\n}\n\ntype LevenshteinResult = {\n    title: string,\n    score: number,\n    subOrDub: SubOrDub\n}\n\ntype EpisodeProvider = {\n    provider: string,\n    episodeNumber: number | undefined,\n    episodeId: string | undefined,\n    hasDub: boolean | undefined,\n    dubRequested: boolean\n}\n\ntype EpisodeObject = {\n    animeId: string,\n    providers:EpisodeProvider[]\n}\n"
}